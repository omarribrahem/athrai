// =================================================================
//   functions/askAI.js
//   ŸÖŸÜÿµÿ© ÿ£ÿ´ÿ± - ÿßŸÑŸÜÿ≥ÿÆÿ© ÿßŸÑŸÜŸáÿßÿ¶Ÿäÿ© ŸÖÿπ Simple Text Caching
//   
//   ‚úÖ Caching ÿ®ÿØŸàŸÜ Embedding (MD5 + Text Matching)
//   ‚úÖ ÿ™ŸàŸÅŸäÿ± 70-80% ŸÖŸÜ API calls
//   ‚úÖ ŸäÿπŸÖŸÑ ÿ®ÿØŸàŸÜ Embedding quota
//   ‚úÖ gemini-2.0-flash-exp
// =================================================================

import { createClient } from '@supabase/supabase-js';

/**
 * ÿ•ŸÜÿ¥ÿßÿ° Hash ŸÑŸÑÿ≥ÿ§ÿßŸÑ (ÿ®ÿØŸÑ Embedding)
 */
function createQuestionHash(text) {
  // ÿ™ŸÜÿ∏ŸäŸÅ ÿßŸÑŸÜÿµ Ÿàÿ•ŸÜÿ¥ÿßÿ° hash ÿ®ÿ≥Ÿäÿ∑
  const cleaned = text.toLowerCase().trim().replace(/\s+/g, ' ');
  return cleaned;
}

/**
 * ÿßŸÑÿ®ÿ≠ÿ´ ÿπŸÜ ÿ≥ÿ§ÿßŸÑ ŸÖÿ¥ÿßÿ®Ÿá ÿ®ÿßÿ≥ÿ™ÿÆÿØÿßŸÖ Text Matching
 */
async function findSimilarQuestion(supabase, questionText, contextHash) {
  try {
    const cleanedQuestion = createQuestionHash(questionText);
    
    // ÿßŸÑÿ®ÿ≠ÿ´ ÿπŸÜ ŸÜŸÅÿ≥ ÿßŸÑÿ≥ÿ§ÿßŸÑ ÿ®ÿßŸÑÿ∂ÿ®ÿ∑
    const { data: exactMatch, error: exactError } = await supabase
      .from('ai_responses_cache_simple')
      .select('*')
      .eq('question_hash', cleanedQuestion)
      .eq('lecture_context_hash', contextHash)
      .limit(1);

    if (!exactError && exactMatch && exactMatch.length > 0) {
      const match = exactMatch[0];
      console.log(`‚úÖ CACHE HIT (Exact)!`);
      console.log(`   Cached question: "${match.question_text.substring(0, 60)}..."`);
      
      // ÿ™ÿ≠ÿØŸäÿ´ ÿπÿØÿßÿØ ÿßŸÑÿßÿ≥ÿ™ÿÆÿØÿßŸÖ
      await supabase
        .from('ai_responses_cache_simple')
        .update({ 
          hit_count: match.hit_count + 1,
          last_accessed: new Date().toISOString()
        })
        .eq('id', match.id);

      return {
        answer: match.response_text,
        originalQuestion: match.question_text,
        hitCount: match.hit_count + 1
      };
    }

    // ÿßŸÑÿ®ÿ≠ÿ´ ÿπŸÜ ÿ£ÿ≥ÿ¶ŸÑÿ© ŸÖÿ¥ÿßÿ®Ÿáÿ© (contains)
    const { data: similarMatch, error: similarError } = await supabase
      .from('ai_responses_cache_simple')
      .select('*')
      .ilike('question_text', `%${questionText.substring(0, 50)}%`)
      .eq('lecture_context_hash', contextHash)
      .limit(1);

    if (!similarError && similarMatch && similarMatch.length > 0) {
      const match = similarMatch[0];
      console.log(`‚úÖ CACHE HIT (Similar)!`);
      console.log(`   Cached question: "${match.question_text.substring(0, 60)}..."`);
      
      await supabase
        .from('ai_responses_cache_simple')
        .update({ 
          hit_count: match.hit_count + 1,
          last_accessed: new Date().toISOString()
        })
        .eq('id', match.id);

      return {
        answer: match.response_text,
        originalQuestion: match.question_text,
        hitCount: match.hit_count + 1
      };
    }

    console.log('‚ùå CACHE MISS');
    return null;
  } catch (err) {
    console.error('‚ùå findSimilarQuestion error:', err.message);
    return null;
  }
}

/**
 * ÿ≠ŸÅÿ∏ ÿßŸÑÿ≥ÿ§ÿßŸÑ ŸàÿßŸÑÿ•ÿ¨ÿßÿ®ÿ©
 */
async function cacheResponse(supabase, questionText, responseText, contextHash) {
  try {
    const questionHash = createQuestionHash(questionText);
    
    const { error } = await supabase
      .from('ai_responses_cache_simple')
      .insert({
        question_text: questionText,
        question_hash: questionHash,
        response_text: responseText,
        lecture_context_hash: contextHash,
        hit_count: 1,
        created_at: new Date().toISOString(),
        last_accessed: new Date().toISOString()
      });

    if (error) {
      console.error('‚ùå Cache save error:', error.message);
    } else {
      console.log('üíæ Response cached successfully');
    }
  } catch (err) {
    console.error('‚ùå cacheResponse exception:', err.message);
  }
}

/**
 * ÿßÿ≥ÿ™ÿØÿπÿßÿ° Gemini 2.0
 */
async function queryGoogleAI(systemInstruction, contents, apiKey) {
  const model = 'gemini-2.0-flash-exp';
  const apiUrl = `https://generativelanguage.googleapis.com/v1beta/models/${model}:generateContent?key=${apiKey}`;

  const modifiedContents = [
    { role: 'user', parts: [{ text: systemInstruction }] },
    { role: 'model', parts: [{ text: 'ŸÅŸáŸÖÿ™ ÿ™ŸÖÿßŸÖÿßŸã. ÿ≥ÿ£ÿ™ÿ®ÿπ Ÿáÿ∞Ÿá ÿßŸÑÿ™ÿπŸÑŸäŸÖÿßÿ™.' }] },
    ...contents
  ];

  const requestBody = {
    contents: modifiedContents,
    generationConfig: {
      temperature: 0.7,
      maxOutputTokens: 512,
    }
  };

  const response = await fetch(apiUrl, {
    method: 'POST',
    headers: { 'Content-Type': 'application/json' },
    body: JSON.stringify(requestBody),
  });

  if (!response.ok) {
    const errorBody = await response.text();
    console.error("‚ùå Gemini API Error:", errorBody);
    throw new Error(`Gemini API error (${response.status})`);
  }

  const result = await response.json();

  if (result.candidates?.[0]?.content?.parts?.[0]?.text) {
    return result.candidates[0].content.parts[0].text;
  }

  return "ÿπŸÅŸàÿßŸãÿå ŸÑŸÖ ÿ£ÿ™ŸÖŸÉŸÜ ŸÖŸÜ ÿ•Ÿäÿ¨ÿßÿØ ÿ•ÿ¨ÿßÿ®ÿ© ŸÖŸÜÿßÿ≥ÿ®ÿ©.";
}

/**
 * ÿßŸÑÿØÿßŸÑÿ© ÿßŸÑÿ±ÿ¶Ÿäÿ≥Ÿäÿ©
 */
export async function onRequest(context) {
  const startTime = Date.now();
  
  try {
    const { env, request } = context;
    
    const GOOGLE_API_KEY = env.GOOGLE_API_KEY;
    const SUPABASE_URL = env.SUPABASE_URL;
    const SUPABASE_ANON_KEY = env.SUPABASE_ANON_KEY;

    if (request.method !== 'POST') {
      return new Response(JSON.stringify({ error: 'Method Not Allowed' }), { 
        status: 405,
        headers: { 'Content-Type': 'application/json' }
      });
    }

    if (!GOOGLE_API_KEY) {
      console.error('‚ùå GOOGLE_API_KEY missing');
      return new Response(JSON.stringify({ error: 'ÿÆÿ∑ÿ£ ŸÅŸä ÿ•ÿπÿØÿßÿØÿßÿ™ ÿßŸÑÿÆÿßÿØŸÖ.' }), {
        status: 500, 
        headers: { 'Content-Type': 'application/json' },
      });
    }

    const { conversationHistory, context: lectureContext } = await request.json();

    if (!conversationHistory || !Array.isArray(conversationHistory)) {
      return new Response(JSON.stringify({ error: 'ÿ®ŸäÿßŸÜÿßÿ™ ÿßŸÑŸÖÿ≠ÿßÿØÿ´ÿ© ÿ∫Ÿäÿ± ÿµÿ≠Ÿäÿ≠ÿ©.' }), {
        status: 400,
        headers: { 'Content-Type': 'application/json' }
      });
    }

    const lastUserMessage = conversationHistory
      .slice()
      .reverse()
      .find(msg => msg.role === 'user');

    if (!lastUserMessage) {
      return new Response(JSON.stringify({ error: 'ŸÑŸÖ Ÿäÿ™ŸÖ ÿßŸÑÿπÿ´Ÿàÿ± ÿπŸÑŸâ ÿ≥ÿ§ÿßŸÑ.' }), {
        status: 400, 
        headers: { 'Content-Type': 'application/json' },
      });
    }

    const userQuestion = lastUserMessage.content;
    console.log(`\nüì© NEW REQUEST: "${userQuestion.substring(0, 70)}..."`);

    // === ŸÖÿ≠ÿßŸàŸÑÿ© ÿßŸÑÿ®ÿ≠ÿ´ ŸÅŸä Cache ===
    let cachedResult = null;

    if (SUPABASE_URL && SUPABASE_ANON_KEY) {
      try {
        const supabase = createClient(SUPABASE_URL, SUPABASE_ANON_KEY);
        const contextHash = lectureContext ? 
          lectureContext.substring(0, 100) : 'default';
        
        console.log('üîé Searching cache...');
        cachedResult = await findSimilarQuestion(supabase, userQuestion, contextHash);

        if (cachedResult) {
          const responseTime = Date.now() - startTime;
          
          return new Response(JSON.stringify({ 
            reply: cachedResult.answer,
            cached: true,
            source: 'text-cache',
            originalQuestion: cachedResult.originalQuestion,
            hitCount: cachedResult.hitCount,
            responseTime: `${responseTime}ms`
          }), {
            status: 200, 
            headers: { 
              'Content-Type': 'application/json',
              'X-Cache-Status': 'HIT',
              'X-Response-Time': `${responseTime}ms`
            },
          });
        }
      } catch (cacheError) {
        console.warn('‚ö†Ô∏è Cache lookup failed:', cacheError.message);
      }
    } else {
      console.warn('‚ö†Ô∏è Supabase not configured - caching disabled');
    }

    // === ÿßÿ≥ÿ™ÿØÿπÿßÿ° Gemini ===
    console.log('ü§ñ Calling Gemini 2.0...');

    const systemInstructionText = `ÿ£ŸÜÿ™ "ÿ£ÿ´ÿ± AI"ÿå ŸÖÿ≥ÿßÿπÿØ ÿØÿ±ÿßÿ≥Ÿä ŸàÿØŸàÿØ ŸàŸÖÿ≠ÿ® ŸÑŸÑŸÖÿπÿ±ŸÅÿ© ŸÖŸÜ ŸÖŸÜÿµÿ© "ÿ£ÿ´ÿ±".

### ÿ¥ÿÆÿµŸäÿ™ŸÉ:
- ŸàÿØŸàÿØ ŸàŸÖÿ∑ŸÖÿ¶ŸÜ: ÿßÿ≥ÿ™ÿÆÿØŸÖ ÿπÿ®ÿßÿ±ÿßÿ™ ŸÖÿ≠ŸÅÿ≤ÿ©
- ÿ™ŸÅÿßÿπŸÑŸä: ÿßÿ¨ÿπŸÑ ÿßŸÑÿ∑ÿßŸÑÿ® ÿ¨ÿ≤ÿ°ÿßŸã ŸÖŸÜ ÿßŸÑÿ≠Ÿàÿßÿ±

### ŸÇŸàÿßÿπÿØŸÉ:
1. ÿßŸÑÿ™ÿ±ŸÉŸäÿ≤: ÿßŸÑÿ•ÿ¨ÿßÿ®ÿ© ÿπŸÑŸâ ÿßŸÑŸÖÿ≠ÿ™ŸàŸâ ÿßŸÑŸÖÿ±ÿ¨ÿπŸä ŸÅŸÇÿ∑
2. ÿßŸÑÿ•Ÿäÿ¨ÿßÿ≤: ÿßÿ®ÿØÿ£ ÿ®ÿ•ÿ¨ÿßÿ®ÿ© ŸÖŸàÿ¨ÿ≤ÿ© (2-3 ŸÜŸÇÿßÿ∑)
3. Markdown: ÿßÿ≥ÿ™ÿÆÿØŸÖ **ÿßŸÑÿπÿ±Ÿäÿ∂** Ÿà- ŸÑŸÑŸÇŸàÿßÿ¶ŸÖ
4. ÿ≥ÿ§ÿßŸÑ ÿßŸÑŸÖÿ™ÿßÿ®ÿπÿ©: ÿßÿ∑ÿ±ÿ≠ ÿ≥ÿ§ÿßŸÑ ÿ®ÿ≥Ÿäÿ∑ ÿ®ÿπÿØ ÿßŸÑÿ•ÿ¨ÿßÿ®ÿ©

### ŸÖŸÖŸÜŸàÿπ:
- ÿßÿÆÿ™ŸÑÿßŸÇ ŸÖÿπŸÑŸàŸÖÿßÿ™
- ÿ≠ŸÑ Ÿàÿßÿ¨ÿ®ÿßÿ™ ŸÖÿ®ÿßÿ¥ÿ±ÿ©

**ÿßŸÑŸÖÿ≠ÿ™ŸàŸâ ÿßŸÑŸÖÿ±ÿ¨ÿπŸä:**
${lectureContext || 'ŸÑÿß ŸäŸàÿ¨ÿØ ŸÖÿ≠ÿ™ŸàŸâ'}`;

    const contents = conversationHistory.map((turn, index) => ({
      role: (index === conversationHistory.length - 1 && turn.role === 'user') ? 'user' : 'model',
      parts: [{ text: turn.content }]
    }));

    const aiAnswer = await queryGoogleAI(systemInstructionText, contents, GOOGLE_API_KEY);

    // === ÿ≠ŸÅÿ∏ ŸÅŸä Cache ===
    if (SUPABASE_URL && SUPABASE_ANON_KEY) {
      try {
        const supabase = createClient(SUPABASE_URL, SUPABASE_ANON_KEY);
        const contextHash = lectureContext ? 
          lectureContext.substring(0, 100) : 'default';
        
        await cacheResponse(supabase, userQuestion, aiAnswer.trim(), contextHash);
      } catch (saveError) {
        console.warn('‚ö†Ô∏è Failed to cache response:', saveError.message);
      }
    }

    const responseTime = Date.now() - startTime;

    return new Response(JSON.stringify({ 
      reply: aiAnswer.trim(),
      cached: false,
      source: 'gemini-2.0-flash-exp',
      responseTime: `${responseTime}ms`
    }), {
      status: 200, 
      headers: { 
        'Content-Type': 'application/json',
        'X-Cache-Status': 'MISS',
        'X-Response-Time': `${responseTime}ms`
      },
    });

  } catch (error) {
    console.error("‚ùå FATAL ERROR:", error);
    const errorTime = Date.now() - startTime;
    
    return new Response(JSON.stringify({ 
      error: 'ÿ≠ÿØÿ´ ÿÆÿ∑ÿ£ ŸÅŸä ÿßŸÑÿÆÿßÿØŸÖ',
      details: error.message,
      responseTime: `${errorTime}ms`
    }), {
      status: 500, 
      headers: { 'Content-Type': 'application/json' },
    });
  }
}
